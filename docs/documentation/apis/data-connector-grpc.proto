syntax = "proto3";

package qlik;

message ConnectionInfo
{
    string connectionString = 1;
    string user = 2;
    string password = 3;
}

message SessionInfo
{
    string user = 1;
    string sessionId = 2;
    string docId = 3;
}

message DataInfo
{
    string statement = 1;
    string statementParameters = 2;
}

message GetDataOptions
{
    ConnectionInfo connection = 1;
    SessionInfo sessionInfo = 2;
    DataInfo parameters = 3;
}



/** Qlik field values have three parts. String, Number and Info. Info is not supported at this level.
    Every field value imported will have a string and/or a number.

    This enum is used to indicate null values and other special cases.
*/
enum ValueFlag {
    Normal = 0;
    Null = 1;       /** NullString and NullNum. Use to specify a null value. */
    NullString = 2; /** Missing string as opposed to empty. */
    NullNum = 3;    /** Missing numerical value. */
}

/** A chunk of values for one column.
    The numerical value can be transffered as a double or an integer.
    Inetegers will typically take up less bandwidth than doubles.

    Qlik can recieve any number as a double or an integer. The connector
    can use integers for better network performance.

    Although unusual a feild value can have both a string and a number
    part. Then the strings and one of number arrays will be used at the same
    time. To inidicate a null value or a mising string or number, use
    the flag array.
*/
message Column
{
    repeated string strings = 1;
    repeated double doubles = 2;
    repeated sint64 integers = 3;
    repeated ValueFlag flags = 4;
}

/** Data for one or more rows in the import.
    The datachunk should be serialized as less than 64KB for best performance.
*/
message DataChunk
{
    repeated Column cols = 1;
}

/** Represents a binary stream. Each chunk is slighly less than 64 KB or smaller.
    Use less than 64KB for best performance.
*/
message RawDataChunk
{
    bytes data = 1;
}


/// A structure for horizontal data. Horizontal data starts anywhere in any row
/// and continues for an arbitary length and may wrap to another row. Typically
/// sized to fit 64 KB.
message HorizontalChunk
{
    repeated string stringValues = 1;    /// Strings the bundle
    repeated double doubleValues = 2;    /// Doubles in the bundle.

    repeated sint32 stringIndex = 3;     /// -1 = Null string.
                                         /// -2 = Empty string.
                                         /// Zero or greater = Index into stringValues.

    repeated sint32 numberIndex = 4;     /// -1 = Null number.
                                         /// Zero or greater = Index into doubleValues.
                                         /// -2 = The next index is not an index but a 32bit signed integer value.
}



/** How to interpret the data.
    If dates already in the 1899-12-30 format, then the fastest way to import then is to use SemanticType=DEFAULT.
    And transferr the date as a double and set FieldAttributes::Type = DATE.
    If the dates are in "days since 1904-01-01" format the best way is to add 1462 to them and send as
    1899-12-30 dates.
*/
enum SemanticType {
    DEFAULT = 0;                     /** The normal value. */
    UNIX_SECONDS_SINCE_1970_UTC = 1; /** Transfered as double or integer. Will be converted to (fractional) days since 1899-12-30. */
    ISO_8601 = 2;                    /** Date and time format. Transfered as string. Will be converted to (fractional) days since 1899-12-30. */
}

/** Direct copy of FieldAttrType in Qlik Engine. How to display the data. */
enum FieldAttrType {
    UNKNOWN = 0;
    TEXT = 1;
    REAL = 2;
    DATE = 3;
    TIME = 4;
    TIMESTAMP = 5;
    INTERVAL = 6;
    INTEGER = 10;
    FIX = 11;
    MONEY = 12;
}


/** Subset of classic Qlik Engine number format */
message FieldAttributes
{
    FieldAttrType Type = 1;
}

message FieldInfo
{
    string name = 1;
    SemanticType semanticType = 2;
    FieldAttributes fieldAttributes = 3;
    repeated string tags = 4;             /** Optional field description. Examples: key, text, ASCII. */
}

/** Transferred as initial metadata with the name "x-qlik-getdata-bin". */
message GetDataResponse {
    repeated FieldInfo fieldInfo = 1;
    string tableName = 2;
}

service Connector
{

    /** The standard way to send data.
        First send GetDataResponse as initial meta data.
        Then send HorizontalChunk stream.
    */
    rpc GetHorizontalData(GetDataOptions) returns(stream HorizontalChunk) {}

    /** The standard way to send data.
        First send GetDataResponse as initial meta data.
        Then send DataChunk stream.
    */
    rpc GetData(GetDataOptions) returns(stream DataChunk) {}

    /** An experimental way to send data. The raw method will bypass the slightly expensive protobuf
        encoding and send byte chunks of slightly less than 64KB each as a binary stream. The first 4 bytes
        transfferd is a little endian signed integer with the raw protocol number being used.

        In some cases this method will provide better performance. It is also a more difficult
        to implement. Not ready for public use.

        First send GetDataResponse as initial meta data.
        Then send RawDataChunk stream.
    */
    rpc GetRawData(GetDataOptions) returns(stream RawDataChunk) {}
}
