

## ScriptPrefixes

# Add

The
 **add** 
prefix can be added to any LOAD, SELECT or map...using statement in the
script. It is only relevant during partial reloads.



Partial reload is currently only supported by using the Qlik Engine
API.



 

] (loadstatement | selectstatement | mapstatement)

 

During a partial reload the Qlik Sense table, for which a table name is
generated by the add
/add **SELECT
statement (provided such a table exists), will be appended with the
result of the add
/add **SELECT
statement. No check for duplicates is performed. Therefore, a statement
using the add prefix will normally include either a
 **distinct** 
qualifier or a
 **where** 
clause guarding duplicates. The map...using statement causes mapping to
take place also during partial script
execution.

 

| Argument | Description                                                                                                  |
| -------- | ------------------------------------------------------------------------------------------------------------ |
| only     | An optional qualifier denoting that the statement should be disregarded during normal (non-partial) reloads. |

Examples and results:

<table>
<thead>
<tr class="header">
<th>Example</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Tab1:</p>
<p>LOAD Name, Number FROM Persons.csv;</p>
<p>Add LOAD Name, Number FROM newPersons.csv;</p></td>
<td><p>During normal reload, data is loaded from Persons.csv and stored in the Qlik Sense table Tab1. Data from NewPersons.csv is then concatenated to the same Qlik Sense table.</p>
<p>During partial reload, data is loaded from NewPersons.csv and appended to the Qlik Sense table Tab1. No check for duplicates is made.</p></td>
</tr>
<tr class="even">
<td><p>Tab1:</p>
<p>SQL SELECT Name, Number FROM Persons.csv;</p>
<p>Add LOAD Name, Number FROM NewPersons.csv where not exists(Name);</p></td>
<td><p>A check for duplicates is made by means of looking if Name exists in the previously loaded table data.</p>
<p><em>Exists - script function</em></p>
<p>During normal reload, data is loaded from Persons.csv and stored in the Qlik Sense table Tab1. Data from NewPersons.csv is then concatenated to the same Qlik Sense table.</p>
<p>During partial reload, data is loaded from NewPersons.csv which is appended to the Qlik Sense table Tab1. A check for duplicates is made by means of seeing if Name exists in the previously loaded table data.</p></td>
</tr>
<tr class="odd">
<td><p>Tab1:</p>
<p>LOAD Name, Number FROM Persons.csv;</p>
<p>Add Only LOAD Name, Number FROM NewPersons.csv where not exists(Name);</p></td>
<td><p>During normal reload, data is loaded from Persons.csv and stored in the Qlik Sense table Tab1. The statement loading NewPersons.csv is disregarded.</p>
<p>During partial reload, data is loaded from NewPersons.csv which is appended to the Qlik Sense table Tab1. A check for duplicates is made by means of seeing if Name exists in the previously loaded table data.</p>
<p><em>Exists - script function</em></p></td>
</tr>
</tbody>
</table>

 

*Load*

*Select*

*Map*

Inter-record
functions

*Only*

# Buffer

QVD files can be created and maintained automatically via the
 **buffer** 
prefix. This prefix can be used on most LOAD and SELECT statements in
script. It indicates that QVD files are used to cache/buffer the result
of the
statement.

<div class="note" data-conditions="Targets.NotInEnterprise" data-autonumposition="none">

This function is not supported in Qlik Sense
Cloud.



 

Buffer [(option
[ ,
option]] ( loadstatement | selectstatement )

option::= incremental | stale [after] amount [(days | hours)]

 

If no option is used, the QVD buffer created by the first execution of
the script will be used indefinitely.

The buffer file is stored in the
<span class="path" data-autonumposition="none">Buffers
sub-folder, typically
<span class="path" data-autonumposition="none">C:\\ProgramData\\Qlik\\Sense\\Engine\\Buffers
(server installation) or
<span class="path" data-autonumposition="none">C:\\Users\\{user}\\Documents\\Qlik\\Sense\\Buffers
(Qlik Sense Desktop).

The name of the QVD file is a calculated name, a 160-bit hexadecimal
hash of the entire following LOAD or SELECT statement and other
discriminating info. This means that the QVD buffer will be rendered
invalid by any change in the following LOAD or SELECT statement.

QVD buffers will normally be removed when no longer referenced anywhere
throughout a complete script execution in the app that created it or
when the app that created it no longer exists.

 

<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Argument</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>incremental</td>
<td>The incremental option enables the ability to read only part of an underlying file. Previous size of the file is stored in the XML header in the QVD file. This is particularly useful with log files. All records loaded at a previous occasion are read from the QVD file whereas the following new records are read from the original source and finally an updated QVD-file is created. Note that the incremental option can only be used with LOAD statements and text files and that incremental load cannot be used where old data is changed or deleted!</td>
</tr>
<tr class="even">
<td>stale [after] amount [(days | hours)]</td>
<td>amount is a number specifying the time period. Decimals may be used. The unit is assumed to be days if omitted.
<p>The stale after option is typically used with DB sources where there is no simple timestamp on the original data. Instead you specify how old the QVD snapshot can be to be used. A stale after clause simply states a time period from the creation time of the QVD buffer after which it will no longer be considered valid. Before that time the QVD buffer will be used as source for data and after that the original data source will be used. The QVD buffer file will then automatically be updated and a new period starts.</p></td>
</tr>
</tbody>
</table>

 

Numerous limitations exist, most notable is that there must be either a
file LOAD or a SELECT statement at the core of any complex statement.

 

Buffer SELECT \* from MyTable;

 

Buffer (stale after 7 days) SELECT \* from MyTable;

 

Buffer (incremental) LOAD \* from MyLog.log;

 

*Load*

*Select*

*Working with QVD
files*

# Bundle

The
 **Bundle** 
prefix is used to include external files, such as image or sound files,
or objects connected to a field value, to be stored in the qvf file.

Not working on 31 august 2015. Waiting for implementation in
Sense

 

Bundle [Info]
( loadstatement | selectstatement)

 



Qlik Sense does not support displaying the information loaded using
 and Info.



In order to maintain portability, it is possible to include the external
files into the .qvf file itself. To this end use the
 **Bundle** 
prefix. The bundled info files are compressed in the process, but will
nevertheless take up additional space both in the file and in RAM.
Therefore consider both the size and the number of bundled files before
going for this solution.

The info may be referenced from the layout as normal info, via the chart
info function or as an internal file via the special syntax
// fieldname / fieldvalue alternatively
qmem://
fieldname / \< index \> where index is the internal index of a field
value.

 

<table>
<thead>
<tr class="header">
<th>Argument</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>loadstatement | selectstatement</td>
<td>If a piece of external information, such as an image or a sound file is to be connected to a field value, this is done in a table that is loaded with the  prefix. <p>The  **Info**  prefix may be omitted when **Bundle is used.</p></td>
</tr>
</tbody>
</table>

 

Bundle Info LOAD \* From flagoecd.csv;

Bundle SQL SELECT \* from
infotable;

 

*Info*

*Load*

*Select*

# Concatenate

If two tables that are to be concatenated have different sets of fields,
concatenation of two tables can still be forced with the
 **Concatenate** 
prefix. This statement forces concatenation with an existing named table
or the latest previously created logical
table.

 

[ (tablename
 ] ( loadstatement | selectstatement )

 

A concatenation is in principle the same as the
SQL UNION statement, but with two differences:

  - The
     **Concatenate** 
    prefix can be used no matter if the tables have identical field
    names or not.
  - Identical records are not removed with the
     **Concatenate** 
    prefix.

 

| Argument  | Description                     |
| --------- | ------------------------------- |
| tablename | The name of the existing table. |

 

Concatenate LOAD \* From file2.csv;

Concatenate SELECT \* From table3;

tab1:

LOAD \* From file1.csv;

tab2:

LOAD \* From file2.csv;

.. .. ..

Concatenate (tab1) LOAD \* From file3.csv;

 

*Load*

Concatenating several tables into
one

*Select*

# Crosstable

The
 **crosstable** 
prefix is used to turn a cross table into a straight table, that is, a
wide table with many columns is turned into a tall table, with the
column headings being placed into a single attribute column.

 

crosstable (attribute
field name, data field name [ , n ]
) (
loadstatement | selectstatement
)

 

| Argument             | Description                                                                                         |
| -------------------- | --------------------------------------------------------------------------------------------------- |
| attribute field name | The field that contains the attribute values.                                                       |
| data field name      | The field that contains the data values.                                                            |
| n                    | The number of qualifier fields preceding the table to be transformed to generic form. Default is 1. |

A crosstable is a common type of table featuring a matrix of values
between two or more orthogonal lists of header data, of which one is
used as column headers. A typical example could be to have one column
per month. The result of the
 **crosstable** 
prefix is that the column headers (for example month names) will be
stored in one field, the attribute field, and the column data (month
numbers) will be stored in a second field: the data field.

 

Crosstable (Month, Sales) LOAD \* from ex1.csv;

Crosstable (Month,Sales,2) LOAD \* from ex2.csv;

Crosstable (A,B) SELECT \* from table3;

 

Working with cross
tables

*Generic*

*Load*

*Select*

# First

The
 **First** 
prefix to a
 **LOAD** 
or
SELECT (SQL) statement is used for loading a set maximum number of
records from a data source
table.

 

n ( loadstatement | selectstatement )

 

<table>
<thead>
<tr class="header">
<th>Argument</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>n</td>
<td><p>An arbitrary expression that evaluates to an integer indicating the maximum number of records to be read.</p>
<p>n can be enclosed in parentheses, like (n), but this is not required.</p></td>
</tr>
</tbody>
</table>

 

First 10 LOAD \* from abc.csv;

First (1) SQL SELECT \* from
Orders;

 

*Load*

*Select*

# Generic

The unpacking and loading of a generic database can be done with a
 **generic** 
prefix.

 

( loadstatement | selectstatement )

 

Tables loaded through a
 **generic** 
statement are not auto-concatenated.

 

Generic LOAD \* from abc.csv;

Generic SQL SELECT \* from table1;

 

*Load*

*Select*

*Crosstable*

Generic
databases

# Hierarchy

The
 **hierarchy** 
prefix is used to transform a parent-child hierarchy table to a table
that is useful in a Qlik Sense data model. It can be put in front of a
 **LOAD** 
or a
 **SELECT** 
statement and will use the result of the loading statement as input for
a table transformation.

The prefix creates an expanded nodes table, which normally has the same
number of records as the input table, but in addition each level in the
hierarchy is stored in a separate field. The path field can be used in a
tree structure.

 

Hierarchy (NodeID,
ParentID, NodeName, [ParentName], [PathSource], [PathName],
[PathDelimiter],
[Depth](loadstatement | selectstatement) 

 

The input table must be an adjacent nodes table. Adjacent nodes tables
are tables where each record corresponds to a node and has a field that
contains a reference to the parent node. In such a table the node is
stored on one record only but the node can still have any number of
children. The table may of course contain additional fields describing
attributes for the nodes.

The prefix creates an expanded nodes table, which normally has the same
number of records as the input table, but in addition each level in the
hierarchy is stored in a separate field. The path field can be used in a
tree structure. The levels in an expanded nodes table can easily be used
e.g. in a pivot table and the path field can be used in a tree
structure.

Usually the input table has exactly one record per node and in such a
case the output table will contain the same number of records. However,
sometimes there are nodes with multiple parents, i.e. one node is
represented by several records in the input table. If so, the output
table may have more records than the input table.

All nodes with a parent id not found in the node id column (including
nodes with missing parent id) will be considered as roots. Also, only
nodes with a connection to a root node - direct or indirect - will be
loaded, thus avoiding circular references.

Additional fields containing the name of the parent node, the path of
the node and the depth of the node can be
created.

 

| Argument      | Description                                                                                                                                                                                                                                                           |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| NodeID        | The name of the field that contains the node id. This field must exist in the input table.                                                                                                                                                                            |
| ParentID      | The name of the field that contains the node id of the parent node. This field must exist in the input table.                                                                                                                                                         |
| NodeName      | The name of the field that contains the name of the node. This field must exist in the input table.                                                                                                                                                                   |
| ParentName    | A string used to name the new  field. If omitted, this field will not be created.                                                                       | | ParentSource  | The name of the field that contains the name of the node used to build the node path. Optional parameter. If omitted, **NodeName will be used.                      |
| PathName      | A string used to name the new  field, which contains the path from the root to the node. Optional parameter. If omitted, this field will not be created.      | | PathDelimiter | A string used as delimiter in the new **Path field. Optional parameter. If omitted, ‘/’ will be used.                                                               |
| Depth         | A string used to name the new  **Depth**  field, which contains the depth of the node in the hierarchy. Optional parameter. If omitted, this field will not be created. |

 

Hierarchy(NodeID, ParentID, NodeName, ParentName, NodeName, PathName,
'\\', Depth) LOAD \* inline [

NodeID, ParentID, NodeName

1, 4, London

2, 3, Munich

3, 5, Germany

4, 5, UK

5, ,
Europe

];

 

|        |          |          |           |           |           |            |                         |       |
| ------ | -------- | -------- | --------- | --------- | --------- | ---------- | ----------------------- | ----- |
| NodeID | ParentID | NodeName | NodeName1 | NodeName2 | NodeName3 | ParentName | PathName                | Depth |
| 1      | 4        | London   | Europe    | UK        | London    | UK         | Europe\\UK\\London      | 3     |
| 2      | 3        | Munich   | Europe    | Germany   | Munich    | Germany    | Europe\\Germany\\Munich | 3     |
| 3      | 5        | Germany  | Europe    | Germany   | \-        | Europe     | Europe\\Germany         | 2     |
| 4      | 5        | UK       | Europe    | UK        | \-        | Europe     | Europe\\UK              | 2     |
| 5      |          | Europe   | Europe    | \-        | \-        | \-         | Europe                  | 1     |

 

*Load*

*Select*

Hierarchies

# HierarchyBelongsTo

This prefix is used to transform a parent-child hierarchy table to a
table that is useful in a Qlik Sense data model. It can be put in front
of a
 **LOAD** 
or a
 **SELECT** 
statement and will use the result of the loading statement as input for
a table transformation.

The prefix creates a table containing all ancestor-child relations of
the hierarchy. The ancestor fields can then be used to select entire
trees in the hierarchy. The output table in most cases contains several
records per
node.

 

HierarchyBelongsTo (NodeID,
ParentID, NodeName, AncestorID, AncestorName,
[DepthDiff](loadstatement | selectstatement)

 

The input table must be an adjacent nodes table. Adjacent nodes tables
are tables where each record corresponds to a node and has a field that
contains a reference to the parent node. In such a table the node is
stored on one record only but the node can still have any number of
children. The table may of course contain additional fields describing
attributes for the nodes.

The prefix creates a table containing all ancestor-child relations of
the hierarchy. The ancestor fields can then be used to select entire
trees in the hierarchy. The output table in most cases contains several
records per node.

An additional field containing the depth difference of the nodes can be
created.

 

| Argument     | Description                                                                                                                                                                                                                                                                                          |
| ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| NodeID       | The name of the field that contains the node id. This field must exist in the input table.                                                                                                                                                                                                           |
| ParentID     | The name of the field that contains the node id of the parent node. This field must exist in the input table.                                                                                                                                                                                        |
| NodeName     | The name of the field that contains the name of the node. This field must exist in the input table.                                                                                                                                                                                                  |
| AncestorID   | A string used to name the new ancestor id field, which contains the id of the ancestor node.                                                                                                                                                                                                         |
| AncestorName | A string used to name the new ancestor field, which contains the name of the ancestor node.                                                                                                                                                                                                          |
| DepthDiff    | A string used to name the new  **DepthDiff**  field, which contains the depth of the node in the hierarchy relative the ancestor node. Optional parameter. If omitted, this field will not be created. |

 

HierarchyBelongsTo (NodeID, AncestorID, NodeName, AncestorID,
AncestorName, DepthDiff) LOAD \* inline [

NodeID, AncestorID, NodeName

1, 4, London

2, 3, Munich

3, 5, Germany

4, 5, UK

5, , Europe

];

 

|        |            |          |              |           |
| ------ | ---------- | -------- | ------------ | --------- |
| NodeID | AncestorID | NodeName | AncestorName | DepthDiff |
| 1      | 1          | London   | London       | 0         |
| 1      | 4          | London   | UK           | 1         |
| 1      | 5          | London   | Europe       | 2         |
| 2      | 2          | Munich   | Munich       | 0         |
| 2      | 3          | Munich   | Germany      | 1         |
| 2      | 5          | Munich   | Europe       | 2         |
| 3      | 3          | Germany  | Germany      | 0         |
| 3      | 5          | Germany  | Europe       | 1         |
| 4      | 4          | UK       | UK           | 0         |
| 4      | 5          | UK       | Europe       | 1         |
| 5      | 5          | Europe   | Europe       | 0         |

 

*Load*

*Select*

Hierarchies

# Image_Size

This clause is used with the
 **Info** 
prefix to resize images from a database management system to fit in the
fields.

Not working on 31 august 2015. Waiting for implementation in Sense

 [Image_Size(width,height )]
( loadstatement | selectstatement )

 

| Argument | Description                                  |
| -------- | -------------------------------------------- |
| width    | The width of the image specified in pixels.  |
| height   | The height of the image specified in pixels. |

 

Info Image_Size(122,122) SQL SELECT ID, Photo From
infotable;

 

*Info*

# Info

The
 **info** 
prefix is used to link external information, such as a text file, a
picture or a video to a field value.

Not working on 31 august 2015. Waiting for implementation in
Sense

 

( loadstatement | selectstatement )

 



Qlik Sense does not support displaying the information loaded using
 and Info.



If a piece of external information, such as a text file, a picture or a
video is to be linked to a field value, this is done in a table that is
loaded using an
 **info** 
prefix.(In some cases it will be preferable to store the information
inside the qvf file, by using the
 **bundle** 
prefix. The table must contain two columns only, the first one with the
field values that will form the keys to the information, the second one
containing the information elements, that is, the file names of the
pictures etcetera.

The same applies to, for example, a picture from a database management
system. On a binary field, a blob, the info select statement makes an
implicit
 **bundle** ,
i.e. the binary data will be fetched immediately and stored in the qvf.
The binary data must be the second field in a
 **SELECT** 
statement.

If a picture needs to be resized, the
 **image_size** 
clause can be used.

 

Info LOAD \* from flagoecd.csv;

Info SQL SELECT \* from infotable;

Info SQL SELECT Key, Picture From infotable;

 

Data modeling (page
1)

*Bundle*

*Load*

*Image_Size*

*Select*

# Inner

The
 **join** 
and
 **keep** 
prefixes can be preceded by the prefix
inner.If used
before
 **join** 
it specifies that an inner join should be used. The resulting table will
thus only contain combinations of field values from the raw data tables
where the linking field values are represented in both tables. If used
before
 **keep** ,
it specifies that both raw data tables should be reduced to their common
intersection before being stored in Qlik Sense.

 

 ( Join |
) [ (tablename)
]( |selectstatement
)

 

| Argument                         | Description                                                                                                                                                                                                                                                |
| -------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| tablename                        | The named table to be compared to the loaded table.                                                                                                                                                                                                        |
| loadstatement or selectstatement | The  **LOAD or **SELECT**  statement for the loaded table. |

 

|                                                                   |    |
| ----------------------------------------------------------------- | -- |
| Table1 |    |
| A                                                                 | B  |
| 1                                                                 | aa |
| 2                                                                 | cc |
| 3                                                                 | ee |

|                                                                   |    |
| ----------------------------------------------------------------- | -- |
| Table2 |    |
| A                                                                 | C  |
| 1                                                                 | xx |
| 4                                                                 | yy |

QVTable:

SQL SELECT \* From table1;

inner join SQL SELECT \* From
table2;

|                                                                    |    |    |
| ------------------------------------------------------------------ | -- | -- |
| QVTable |    |    |
| A                                                                  | B  | C  |
| 1                                                                  | aa | xx |

 

QVTab1:

SQL SELECT \* From Table1;

QVTab2:

inner keep SQL SELECT \* From
Table2;

|                                                                   |    |
| ----------------------------------------------------------------- | -- |
| QVTab1 |    |
| A                                                                 | B  |
| 1                                                                 | aa |

|                                                                   |    |
| ----------------------------------------------------------------- | -- |
| QVTab2 |    |
| A                                                                 | C  |
| 1                                                                 | xx |

The two tables in the
 **keep** 
example are, of course, associated via
A.

 

*Join*

*Keep*

*Outer*

*Left*

*Right*

# IntervalMatch

The
 **IntervalMatch** 
prefix is used to create a table matching discrete numeric values to one
or more numeric intervals, and optionally matching the values of one or
several additional keys.

 

IntervalMatch (matchfield)(loadstatement | selectstatement )

IntervalMatch (matchfield,keyfield1
[ , keyfield2, ... keyfield5 ]
 (loadstatement | selectstatement )

 

The IntervalMatch prefix must be placed before a
 **LOAD** 
or a
 **SELECT** 
statement that loads the intervals. The field containing the discrete
data points (Time in the example below) and additional keys must already
have been loaded into Qlik Sense before the statement with the
 **IntervalMatch** 
prefix. The prefix does not by itself read this field from the database
table. The prefix transforms the loaded table of intervals and keys to a
table that contains an additional column: the discrete numeric data
points. It also expands the number of records so that the new table has
one record per possible combination of discrete data point, interval and
value of the key field(s).

The intervals may be overlapping and the discrete values will be linked
to all matching intervals.

When the IntervalMatch prefix is extended with key fields, it is used to
create a table matching discrete numeric values to one or more numeric
intervals, while at the same time matching the values of one or several
additional keys.

In order to avoid undefined interval limits being disregarded, it may be
necessary to allow NULL values to map to other fields that constitute
the lower or upper limits to the interval. This can be handled by the
 **NullAsValue** 
statement or by an explicit test that replaces NULL values with a
numeric value well before or after any of the discrete numeric data
points.

 

| Argument                       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| matchfield                     | The field containing the discrete numeric values to be linked to intervals.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| keyfield                       | Fields that contain the additional attributes that are to be matched in the transformation.                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| loadstatementorselectstatement | Must result in a table, where the first field contains the lower limit of each interval, the second field contains the upper limit of each interval, and in the case of using key matching, the third and any subsequent fields contain the keyfield(s) present in the  **IntervalMatch**  statement. The intervals are always closed, i.e. the end points are included in the interval. Non-numeric limits render the interval to be disregarded (undefined). |

 

In the two tables below, the first one lists a number of discrete events
and the second one defines the start and end times for the production of
different orders. By means of the
 **IntervalMatch** 
prefix it is possible to logically connect the two tables in order to
find out e.g. which orders were affected by disturbances and which
orders were processed by which
shifts.



EventLog: LOAD \* Inline [ Time, Event, Comment 00:00, 0, Start of
shift 1 01:18, 1, Line stop 02:23, 2, Line restart 50% 04:15, 3, Line
speed 100% 08:00, 4, Start of shift 2 11:43, 5, End of production ];
OrderLog: LOAD \* INLINE [ Start, End, Order 01:00, 03:35, A 02:30,
07:58, B 03:04, 10:27, C 07:23, 11:43, D ]; //Link the field Time to
the time intervals defined by the fields Start and End. Inner Join
IntervalMatch ( Time ) LOAD Start, End Resident OrderLog;



 

The table
 **OrderLog** 
contains now an additional column:
Time.
The number of records is also expanded.

| Time  | Start | End   | Order |
| ----- | ----- | ----- | ----- |
| 00:00 | \-    | \-    | \-    |
| 01:18 | 01:00 | 03:35 | A     |
| 02:23 | 01:00 | 03:35 | A     |
| 04:15 | 02:30 | 07:58 | B     |
| 04:15 | 03:04 | 10:27 | C     |
| 08:00 | 03:04 | 10:27 | C     |
| 08:00 | 07:23 | 11:43 | D     |
| 11:43 | 07:23 | 11:43 | D     |

(using keyfield)

Same example than above, adding
ProductionLine as a key
field.



EventLog:





LOAD \* Inline
[





Time, Event, Comment,
ProductionLine





00:00, 0, Start of shift 1,
P1





01:00, 0, Start of shift 1,
P2





01:18, 1, Line stop,
P1





02:23, 2, Line restart 50%,
P1





04:15, 3, Line speed 100%,
P1





08:00, 4, Start of shift 2,
P1





09:00, 4, Start of shift 2,
P2





11:43, 5, End of production,
P1





11:43, 5, End of production,
P2





];





 





OrderLog:





LOAD \* INLINE
[





Start, End, Order,
ProductionLine





01:00, 03:35, A,
P1





02:30, 07:58, B,
P1





03:04, 10:27, C,
P1





07:23, 11:43, D,
P2





];





 





//Link the field Time to the time intervals defined by the fields Start
and End and match the
values





// to the key
ProductionLine.





Inner
Join





IntervalMatch ( Time, ProductionLine
)





LOAD Start, End,
ProductionLine





Resident OrderLog;



 

A table box could now be created as
below:

| ProductionLine | Time  | Event | Comment           | Order | Start | End   |
| -------------- | ----- | ----- | ----------------- | ----- | ----- | ----- |
| P1             | 00:00 | 0     | Start of shift 1  | \-    | \-    | \-    |
| P2             | 01:00 | 0     | Start of shift 1  | \-    | \-    | \-    |
| P1             | 01:18 | 1     | Line stop         | A     | 01:00 | 03:35 |
| P1             | 02:23 | 2     | Line restart 50%  | A     | 01:00 | 03:35 |
| P1             | 04:15 | 3     | Line speed 100%   | B     | 02:30 | 07:58 |
| P1             | 04:15 | 3     | Line speed 100%   | C     | 03:04 | 10:27 |
| P1             | 08:00 | 4     | Start of shift 2  | C     | 03:04 | 10:27 |
| P2             | 09:00 | 4     | Start of shift 2  | D     | 07:23 | 11:43 |
| P1             | 11:43 | 5     | End of production | \-    | \-    | \-    |
| P2             | 11:43 | 5     | End of production | D     | 07:23 | 11:43 |

# Join

The
 **join** 
prefix joins the loaded table with an existing named table or the last
previously created data
table.

 

inner | outer | left | right ]Join [ (tablename
 ]( loadstatement | selectstatement )

 

The join is a natural join made over all the common fields. The join
statement may be preceded by one of the prefixes
, **outer,
 **left** 
or
 **right** .

 

| Argument                         | Description                                                                                                                                                                                                                                                |
| -------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| tablename                        | The named table to be compared to the loaded table.                                                                                                                                                                                                        |
| loadstatement or selectstatement | The  **LOAD or **SELECT**  statement for the loaded table. |

 

Join LOAD \* from abc.csv;

 

Join SELECT \* from table1;

 

tab1:

LOAD \* from file1.csv;

tab2:

LOAD \* from file2.csv;

.. .. ..

join (tab1) LOAD \* from file3.csv;

 

*Inner*

*Outer*

*Left*

*Right*

*Keep*

*Combining tables with Join and
Keep*

# Keep

The
 **keep** 
prefix is similar to the
 **join** 
prefix. Just as the
 **join** 
prefix, it compares the loaded table with an existing named table or the
last previously created data table, but instead of joining the loaded
table with an existing table, it has the effect of reducing one or both
of the two tables before they are stored in Qlik Sense, based on the
intersection of table data. The comparison made is equivalent to a
natural join made over all the common fields, i.e. the same way as in a
corresponding join. However, the two tables are not joined and will be
kept in Qlik Sense as two separately named
tables.

 

inner | left |
right)
keep
[(tablename ) ](
loadstatement | selectstatement )

 

The
 **keep** 
prefix must be preceded by one of the prefixes
, **left
or
 **right** .

The explicit
 **join** 
prefix in Qlik Sense script language performs a full join of the two
tables. The result is one table. In many cases such joins will result in
very large tables. One of the main features of Qlik Sense is its ability
to make associations between multiple tables instead of joining them,
which greatly reduces memory usage, increases processing speed and
offers enormous flexibility. Explicit joins should therefore generally
be avoided in Qlik Sense scripts. The keep functionality was designed to
reduce the number of cases where explicit joins needs to be
used.

 

| Argument                         | Description                                                                                                                                                                                                                                                |
| -------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| tablename                        | The named table to be compared to the loaded table.                                                                                                                                                                                                        |
| loadstatement or selectstatement | The  **LOAD or **SELECT**  statement for the loaded table. |

 

Inner Keep LOAD \* from abc.csv;

Left Keep SELECT \* from table1;

tab1:

LOAD \* from file1.csv;

tab2:

LOAD \* from file2.csv;

.. .. ..

Left Keep (tab1) LOAD \* from
file3.csv;

 

*Join*

*Load*

*Inner*

*Select*

*Left*

*Right*

# Left

The
 **Join** 
and
 **Keep** 
prefixes can be preceded by the prefix
 **left** .

If used before
 **join** 
it specifies that a left join should be used. The resulting table will
only contain combinations of field values from the raw data tables where
the linking field values are represented in the first table. If used
before
 **keep** ,
it specifies that the second raw data table should be reduced to its
common intersection with the first table, before being stored in Qlik
Sense.



Were you looking for the string function by the same name? See: *Left -
script and chart function*



 

 ( Join |
) [ (tablename)
](loadstatement
|
selectstatement)

 

| Argument                         | Description                                                                                                                                                                                                                                                |
| -------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| tablename                        | The named table to be compared to the loaded table.                                                                                                                                                                                                        |
| loadstatement or selectstatement | The  **LOAD or **SELECT**  statement for the loaded table. |

 

|        |    |
| ------ | -- |
| Table1 |    |
| A      | B  |
| 1      | aa |
| 2      | cc |
| 3      | ee |

|        |    |
| ------ | -- |
| Table2 |    |
| A      | C  |
| 1      | xx |
| 4      | yy |

QVTable:

SELECT \* From table1;

Left Join Sselect \* From table2;

|         |    |    |
| ------- | -- | -- |
| QVTable |    |    |
| A       | B  | C  |
| 1       | aa | xx |
| 2       | cc |    |
| 3       | ee |    |

QVTab1:

SELECT \* From Table1;

QVTab2:

Left Keep SELECT \* From Table2;

|        |    |
| ------ | -- |
| QVTab1 |    |
| A      | B  |
| 1      | aa |
| 2      | cc |
| 3      | ee |

|        |    |
| ------ | -- |
| QVTab2 |    |
| A      | C  |
| 1      | xx |

The two tables in the
 **keep** 
example are, of course, associated via A.

tab1:

LOAD \* From file1.csv;

tab2:

LOAD \* From file2.csv;

.. .. ..

Left Keep (tab1) LOAD \* From
file3.csv;

 

*Join*

*Keep*

*Inner*

*Outer*

*Right*

# Mapping

The
 **mapping** 
prefix is used to create a mapping table that can be used to, for
example, replacing field values and field names during script
execution.

 

Mapping(
loadstatement |
selectstatement )

 

The
 **mapping** 
prefix can be put in front of a
 **LOAD** 
or a
 **SELECT** 
statement and will store the result of the loading statement as a
mapping table. Mapping provides an efficient way to substituting field
values during script execution, e.g. replacing US, U.S. or America with
USA. A mapping table consists of two columns, the first containing
comparison values and the second containing the desired mapping values.
Mapping tables are stored temporarily in memory and dropped
automatically after script execution.

The content of the mapping table can be accessed using e.g. the
Map … Using statement, the
Rename Field statement, the
 **Applymap()** 
function or the
 **Mapsubstring()** 
function.

 

In this example we load a list of salespersons with a country code
representing their country of residence. We use a table mapping a
country code to a country to replace the country code with the country
name. Only three countries are defined in the mapping table, other
country codes are mapped to 'Rest of the
world'.



// Load mapping table of country codes: map1: mapping LOAD \* Inline [
CCode, Country Sw, Sweden Dk, Denmark No, Norway ] ; // Load list of
salesmen, mapping country code to country // If the country code is not
in the mapping table, put Rest of the world Salespersons: LOAD \*,
ApplyMap('map1', CCode,'Rest of the world') As Country Inline [ CCode,
Salesperson Sw, John Sw,
Mary





Sw, Per Dk, Preben Dk, Olle No, Ole Sf, Risttu] ; // We don't need the
CCode anymore Drop Field 'CCode';



The resulting table looks like this:

| Salesperson | Country           |
| ----------- | ----------------- |
| John        | Sweden            |
| Mary        | Sweden            |
| Per         | Sweden            |
| Preben      | Denmark           |
| Olle        | Denmark           |
| Ole         | Norway            |
| Risttu      | Rest of the world |

 

*Load*

*Select*

*Map*

*Unmap*

*ApplyMap - script function*

*MapSubstring - script function*

*Mapping
functions*

# NoConcatenate

The
 **NoConcatenate** 
prefix forces two loaded tables with identical field sets to be treated
as two separate internal tables, when they would otherwise be
automatically
concatenated.

 

( loadstatement | selectstatement ) 

 

LOAD A,B from file1.csv;

NoConcatenate LOAD A,B from file2.csv;

 

Concatenating several tables into
one

*Load*

*Select*

# Outer

The explicit
 **Join** 
prefix can be preceded by the prefix
 **Outer** 
in order to specify an outer join. In an outer join all combinations
between the two tables are generated. The resulting table will thus
contain combinations of field values from the raw data tables where the
linking field values are represented in one or both tables. The explicit
 **Join** 
prefix can be preceded by the prefix
 **Outer** 
in order to specify an outer join. In an outer join, the resulting table
will contain all values from both raw tables where the linking field
values are represented in either one or both tables. The
 **Outer** 
keyword is optional and is the default join type used when a join prefix
is not specified.

 

Outer Join
[
(tablename)
](loadstatement |selectstatement
)

 

| Argument                         | Description                                                                                                                                                                                                                                                |
| -------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| tablename                        | The named table to be compared to the loaded table.                                                                                                                                                                                                        |
| loadstatement or selectstatement | The  **LOAD or **SELECT**  statement for the loaded table. |

 

|        |    |
| ------ | -- |
| Table1 |    |
| A      | B  |
| 1      | aa |
| 2      | cc |
| 3      | ee |

|        |    |
| ------ | -- |
| Table2 |    |
| A      | C  |
| 1      | xx |
| 4      | yy |

SQL SELECT \* from table1;

join SQL SELECT \* from table2;

OR

SQL SELECT \* from table1;

outer join SQL SELECT \* from table2;

|              |    |    |
| ------------ | -- | -- |
| Joined table |    |    |
| A            | B  | C  |
| 1            | aa | xx |
| 2            | cc | \- |
| 3            | ee | \- |
| 4            | \- | yy |

 

*Join*

*Inner*

*Left*

# Replace

The
 **replace** 
prefix is used to drop the entire Qlik Sense table and replace it with a
new table that is loaded or selected.



Partial reload is currently only supported by using the Qlik Engine
API.



 

(loadstatement |selectstatement |map...usingstatement)

 

The
 **replace** 
prefix can be added to any
, **SELECT
or
 **map...using** 
statement in the script. The
replace LOAD/replace SELECT statement has the effect of dropping the entire Qlik Sense
table, for which a table name is generated by the
replace LOAD/replace SELECT statement, and replacing it with a new table containing
the result of the
replace LOAD/replace SELECT statement. The effect is the same during partial reload
and full reload. The
replace map...using statement causes mapping to take place also during
partial script
execution.

 

| Argument | Description                                                                                                  |
| -------- | ------------------------------------------------------------------------------------------------------------ |
| only     | An optional qualifier denoting that the statement should be disregarded during normal (non-partial) reloads. |

Examples and results:

<table>
<thead>
<tr class="header">
<th>Example</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Tab1:</p>
<p>Replace LOAD * from File1.csv;</p></td>
<td>During both normal and partial reload, the Qlik Sense table Tab1 is initially dropped. Thereafter new data is loaded from File1.csv and stored in Tab1.</td>
</tr>
<tr class="even">
<td><p>Tab1:</p>
<p>Replace only LOAD * from File1.csv;</p></td>
<td><p>During normal reload, this statement is disregarded.</p>
<p>During partial reload, any Qlik Sense table previously named Tab1 is initially dropped. Thereafter new data is loaded from File1.csv and stored in Tab1.</p></td>
</tr>
<tr class="odd">
<td><p>Tab1:</p>
<p>LOAD a,b,c from File1.csv;</p>
<p>Replace LOAD a,b,c from File2.csv;</p></td>
<td><p>During normal reload, the file File1.csv is first read into the Qlik Sense table Tab1, but then immediately dropped and replaced by new data loaded from File2.csv. All data from File1.csv is lost.</p>
<p>During partial reload, the entire Qlik Sense table Tab1 is initially dropped. Thereafter it is replaced by new data loaded from File2.csv.</p></td>
</tr>
<tr class="even">
<td><p>Tab1:</p>
<p>LOAD a,b,c from File1.csv;</p>
<p>Replace only LOAD a,b,c from File2.csv;</p></td>
<td><p>During normal reload, data is loaded from File1.csv and stored in the Qlik Sense table Tab1. File2.csv is disregarded.</p>
<p>During partial reload, the entire Qlik Sense table Tab1 is initially dropped. Thereafter it is replaced by new data loaded from File2.csv. All data from File1.csv is lost.</p></td>
</tr>
</tbody>
</table>

 

*Load*

*Select*

*Map*

*Replace*

*Only*

# Right

The
 **Join** 
and
 **Keep** 
prefixes can be preceded by the prefix
 **right** .

If used before
 **join** 
it specifies that a right join should be used. The resulting table will
only contain combinations of field values from the raw data tables where
the linking field values are represented in the second table. If used
before
 **keep** ,
it specifies that the first raw data table should be reduced to its
common intersection with the second table, before being stored in Qlik
Sense.



Were you looking for the string function by the same name? See: *Right -
script and chart function*



 

 (Join |
) [(tablename)](loadstatement
|selectstatement )

 

| Argument                         | Description                                                                                                                                                                                                                                                |
| -------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| tablename                        | The named table to be compared to the loaded table.                                                                                                                                                                                                        |
| loadstatement or selectstatement | The  **LOAD or **SELECT**  statement for the loaded table. |

 

|        |    |
| ------ | -- |
| Table1 |    |
| A      | B  |
| 1      | aa |
| 2      | cc |
| 3      | ee |

|        |    |
| ------ | -- |
| Table2 |    |
| A      | C  |
| 1      | xx |
| 4      | yy |

QVTable:

SQL SELECT \* from table1;

right join SQL SELECT \* from table2;

|         |    |    |
| ------- | -- | -- |
| QVTable |    |    |
| A       | B  | C  |
| 1       | aa | xx |
| 4       | \- | yy |

QVTab1:

SQL SELECT \* from Table1;

QVTab2:

right keep SQL SELECT \* from Table2;

|        |    |
| ------ | -- |
| QVTab1 |    |
| A      | B  |
| 1      | aa |

|        |    |
| ------ | -- |
| QVTab2 |    |
| A      | C  |
| 1      | xx |
| 4      | yy |

The two tables in the
 **keep** 
example are, of course, associated via A.

tab1:

LOAD \* from file1.csv;

tab2:

LOAD \* from file2.csv;

.. .. ..

right keep (tab1) LOAD \* from
file3.csv;

 

*Join*

*Keep*

*Inner*

*Outer*

*Left*

# Sample

The
 **sample** 
prefix to a
 **LOAD** 
or
 **SELECT** 
statement is used for loading a random sample of records from the data
source.

 

 p ( loadstatement | selectstatement )

 

<table>
<thead>
<tr class="header">
<th>Argument</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>p</td>
<td><p>An arbitrary expression which valuates to a number larger than 0 and lower or equal to 1. The number indicates the probability for a given record to be read.</p>
<p>All records will be read but only some of them will be loaded into Qlik Sense.</p></td>
</tr>
</tbody>
</table>

 

Sample 0.15 SQL SELECT \* from Longtable;

Sample(0.15) LOAD \* from Longtab.csv;



The parentheses are allowed but not
required.



 

*Load*

*Select*

# Script prefixes

Prefixes may be applied to applicable regular statements but never to
control statements. The
 **when** 
and
 **unless** 
prefixes can however be used as suffixes to a few specific control
statement clauses.

All script keywords can be typed with any combination of lower case and
upper case characters. Field and variable names used in the statements
are however case sensitive.

## Script prefixes overview

Each function is described further after the overview. You can also
click the function name in the syntax to immediately access the details
for that specific function.

Use the drop-down on each function to see a brief description and the
syntax of each function. Click the function name in the syntax
description for further details. Please refer to the Qlik Sense online
help for further details about the functions.

Add

The
 **add** 
prefix can be added to any LOAD, SELECT or map...using statement in the
script. It is only relevant during partial
reloads.

 [only] (loadstatement | selectstatement | mapstatement)

Buffer

QVD files can be created and maintained automatically via the
 **buffer** 
prefix. This prefix can be used on most LOAD and SELECT statements in
script. It indicates that QVD files are used to cache/buffer the result
of the
statement.

**Buffer4009643622**[(option
[ ,
option]] ( loadstatement | selectstatement )

option::= incremental | stale [after] amount [(days | hours)]

Bundle

The
 **Bundle** 
prefix is used to include external files, such as image or sound files,
or objects connected to a field value, to be stored in the qvf
file.

 [Info]
( loadstatement | selectstatement)

Concatenate

If two tables that are to be concatenated have different sets of fields,
concatenation of two tables can still be forced with the
 **Concatenate** 
prefix.

[ (tablename
 ] ( loadstatement | selectstatement )

Crosstable

The
 **crosstable** 
prefix is used to turn a cross table into a straight table, that is, a
wide table with many columns is turned into a tall table, with the
column headings being placed into a single attribute
column.

**crosstable1314389182** (attribute
field name, data field name [ , n ]
 ( loadstatement | selectstatement )

First

The
 **First** 
prefix to a
 **LOAD** 
or
SELECT (SQL) statement is used for loading a set maximum number of
records from a data source
table.

n( loadstatement | selectstatement )

Generic

The unpacking and loading of a generic database can be done with a
 **generic** 
prefix.

( loadstatement | selectstatement )

Hierarchy

The
 **hierarchy** 
prefix is used to transform a parent-child hierarchy table to a table
that is useful in a Qlik Sense data model. It can be put in front of a
 **LOAD** 
or a
 **SELECT** 
statement and will use the result of the loading statement as input for
a table
transformation.

**Hierarchy2168927418** (NodeID,
ParentID, NodeName, [ParentName], [PathSource], [PathName],
[PathDelimiter],
[Depth](loadstatement | selectstatement) 

HierarchBelongsTo

This prefix is used to transform a parent-child hierarchy table to a
table that is useful in a Qlik Sense data model. It can be put in front
of a
 **LOAD** 
or a
 **SELECT** 
statement and will use the result of the loading statement as input for
a table
transformation.

**HierarchyBelongsTo1313272620** (NodeID,
ParentID, NodeName, AncestorID, AncestorName,
[DepthDiff](loadstatement | selectstatement)

Image_Size

This clause is used with the
 **Info** 
prefix to resize images from a database management system to fit in the
fields.

 [**Image_Size4109899296**(width,height )]
( loadstatement | selectstatement )

Info

The
 **info** 
prefix is used to link external information, such as a text file, a
picture or a video to a field
value.

( loadstatement | selectstatement )

Inner

The
 **join** 
and
 **keep** 
prefixes can be preceded by the prefix
inner.If used
before
 **join** 
it specifies that an inner join should be used. The resulting table will
thus only contain combinations of field values from the raw data tables
where the linking field values are represented in both tables. If used
before
 **keep** ,
it specifies that both raw data tables should be reduced to their common
intersection before being stored in Qlik Sense.
.

 ( Join |
) [ (tablename)
]( |selectstatement
)

IntervalMatch

The
 **IntervalMatch** 
prefix is used to create a table matching discrete numeric values to one
or more numeric intervals, and optionally matching the values of one or
several additional
keys.

**IntervalMatch2437058544** (matchfield)(loadstatement | selectstatement )

IntervalMatch (matchfield,keyfield1
[ , keyfield2, ... keyfield5 ]
 (loadstatement | selectstatement )

Join

The
 **join** 
prefix joins the loaded table with an existing named table or the last
previously created data table.

[Inner | Outer |
Left | Right
] [ (tablename
 ]( loadstatement | selectstatement )

Keep

The
 **keep** 
prefix is similar to the
 **join** 
prefix. Just as the
 **join** 
prefix, it compares the loaded table with an existing named table or the
last previously created data table, but instead of joining the loaded
table with an existing table, it has the effect of reducing one or both
of the two tables before they are stored in Qlik Sense, based on the
intersection of table data. The comparison made is equivalent to a
natural join made over all the common fields, i.e. the same way as in a
corresponding join. However, the two tables are not joined and will be
kept in Qlik Sense as two separately named tables.

(Inner | Left | Right) **Keep78665222** [(tablename ) ]( loadstatement | selectstatement )

Left

The
 **Join** 
and
 **Keep** 
prefixes can be preceded by the prefix
 **left** .

If used before
 **join** 
it specifies that a left join should be used. The resulting table will
only contain combinations of field values from the raw data tables where
the linking field values are represented in the first table. If used
before
 **keep** ,
it specifies that the second raw data table should be reduced to its
common intersection with the first table, before being stored in Qlik
Sense.

 ( Join |
) [ (tablename)
]( |selectstatement
)

Mapping

The
 **mapping** 
prefix is used to create a mapping table that can be used to, for
example, replacing field values and field names during script execution.

**Mapping2818989540** ( loadstatement | selectstatement )

NoConcatenate

The
 **NoConcatenate** 
prefix forces two loaded tables with identical field sets to be treated
as two separate internal tables, when they would otherwise be
automatically
concatenated.

( loadstatement | selectstatement )

Outer

The explicit
 **Join** 
prefix can be preceded by the prefix
 **Outer** 
in order to specify an outer join. In an outer join all combinations
between the two tables are generated. The resulting table will thus
contain combinations of field values from the raw data tables where the
linking field values are represented in one or both tables. The explicit
 **Join** 
prefix can be preceded by the prefix
 **Outer** 
in order to specify an outer join. In an outer join, the resulting table
will contain all values from both raw tables where the linking field
values are represented in either one or both tables. The
 **Outer** 
keyword is optional and is the default join type used when a join prefix
is not
specified.

**Outer1861602136** Join [
 ](loadstatement |selectstatement )

Replace

The
 **replace** 
prefix is used to drop the entire Qlik Sense table and replace it with a
new table that is loaded or
selected.

(loadstatement |selectstatement |map...usingstatement)

Right

The
 **Join** 
and
 **Keep** 
prefixes can be preceded by the prefix
 **right** .

If used before
 **join** 
it specifies that a right join should be used. The resulting table will
only contain combinations of field values from the raw data tables where
the linking field values are represented in the second table. If used
before
 **keep** ,
it specifies that the first raw data table should be reduced to its
common intersection with the second table, before being stored in Qlik
Sense.

 (Join |
) [(tablename)](loadstatement
|selectstatement )

Sample

The
 **sample** 
prefix to a
 **LOAD** 
or
 **SELECT** 
statement is used for loading a random sample of records from the data
source.

p ( loadstatement | selectstatement )

Semantic

Tables containing relations between records can be loaded through a
 **semantic** 
prefix. This can for example be self-references within a table, where
one record points to another, such as parent, belongs to, or
predecessor.

( loadstatement | selectstatement)

Unless

The
 **unless** 
prefix and suffix is used for creating a conditional clause which
determines whether a statement or exit clause should be evaluated or
not. It may be seen as a compact alternative to the full
if..end if statement.

(**Unless1388775149** condition statement | exitstatement Unless
condition )

When

The
 **when** 
prefix and suffix is used for creating a conditional clause which
determines whether a statement or exit clause should be executed or not.
It may be seen as a compact alternative to the full
if..end if statement.

( **When2651795481** condition statement | exitstatement when condition
)

# Semantic

Tables containing relations between records can be loaded through a
 **semantic** 
prefix. This can for example be self-references within a table, where
one record points to another, such as parent, belongs to, or
predecessor.

 

( loadstatement | selectstatement)

 

The semantic load will create semantic fields that can be displayed in
filter panes to be used for navigation in the data.

Tables loaded through a
 **semantic** 
statement cannot be concatenated.

 

Semantic LOAD \* from abc.csv;

Semantic SELECT Object1, Relation, Object2, InverseRelation from
table1;

 

*Load*

*Select*

# Unless

The
 **unless** 
prefix and suffix is used for creating a conditional clause which
determines whether a statement or exit clause should be evaluated or
not. It may be seen as a compact alternative to the full
if..end if
statement.

 

(Unless condition
statement |
exitstatement condition )

 

The
 **statement** 
or the
 **exitstatement** 
will only be executed if
 **condition** 
is evaluated to False.

The
 **unless** 
prefix may be used on statements which already have one or several other
statements, including additional
 **when** 
or
 **unless** 
prefixes.

 

| Argument      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| condition     | A logical expression evaluating to True or False.                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| statement     | Any Qlik Sense script statement except control statements.                                                                                                                                                                                                                                                                                                                                                                                                                           |
| exitstatement | An  **exit for, **exit do or **exit sub clause or an **exit script**  statement. |

 

exit script unless A=1;

unless A=1 LOAD \* from myfile.csv;

unless A=1 when B=2 drop table
Tab1;

# When

The
 **when** 
prefix and suffix is used for creating a conditional clause which
determines whether a statement or exit clause should be executed or not.
It may be seen as a compact alternative to the full
if..end if
statement.

 

(when condition
statement |
exitstatement condition )

 

The statement
or the
exitstatement
will only be executed if condition is evaluated to True.

The
 **when** 
prefix may be used on statements which already have one or several other
statements, including additional
 **when** 
or
 **unless** 
prefixes.

 

| Argument      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| condition     | A logical expression evaluating to True or False.                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| statement     | Any Qlik Sense script statement except control statements.                                                                                                                                                                                                                                                                                                                                                                                                                           |
| exitstatement | An  **exit for, **exit do or **exit sub clause or an **exit script**  statement. |

 

exit script when A=1;

 

when A=1 LOAD \* from myfile.csv;

 

when A=1 unless B=2 drop table
Tab1;